from unicorn import *
from unicorn.x86_const import *
import pefile
import struct

def gen_key(bss_virtual_address):
    campaignDate = b"Apr 26 2022"
    
    keyPart1 = struct.unpack("<I", campaignDate[0:4])[0]
    keyPart2 = struct.unpack("<I", campaignDate[4:8])[0]
    
    stringKey = keyPart1 + keyPart2 
    stringKey += bss_virtual_address
    stringKey += 18
    print(hex(stringKey))
    return stringKey



file_data = open('C:/Users/Alessandro/Desktop/ursnif_unpacked.bin','rb').read()
pe = pefile.PE(data=file_data)

for s in pe.sections:
    if b'.bss' in s.Name[:6]: 
        bss_virtual_address = s.VirtualAddress
        bss_section_size = 0x1000
        #section_align(s.Misc_VirtualSize)
        bss_section_data = s.get_data()


code = bytes.fromhex('8B040A8BF885C0750AC744241001000000EB0D2B74240C03C689018BF783C104FF4C241075DA')

# Unicorn emulator setup.
uc = Uc(UC_ARCH_X86, UC_MODE_32)

stack_base = 0x00100000
stack_size = 0x00100000

# ESP is moved in the middle of the stack in order to handle.
# instruction that uses ESP as base address (e.g., [esp + 0xc]).
ESP = stack_base + (stack_size // 2)

# Map the stack memory into the emulator and feed it with null byte.
uc.mem_map(stack_base, stack_size)
uc.mem_write(stack_base, b"\x00" * stack_size)
# Write python variable ESP in emulator ESP register.
uc.reg_write(UC_X86_REG_ESP, ESP) 

data_base = 0x00200000
data_size = 0x00100000

# Map the data memory with r/w/x permissions avoiding access violation.
uc.mem_map(data_base, data_size, UC_PROT_ALL)
uc.mem_write(data_base, b"\x00" * data_size)
# Data section needs to be filled with .bss data.
uc.mem_write(data_base, bss_section_data)

# ----- Arguments Setup --------- #
# Setting up key parameter.
key = gen_key(bss_virtual_address)

# Generate key bytes.
key_bytes = struct.pack('<I', key)

# Write key byte on the stack.
uc.mem_write(ESP, key_bytes)

# key bytes are located at ESP+0xC.
# To handle that istrution properly, we need to shift ESP of 0xC bytes.
ESP -= 0xC

# EDX is going to be used as a pointer to the encrypted data.
# It will be used as a base address: [edx + ecx].
# It needs to be initialized at base address of our data.
uc.reg_write(UC_X86_REG_EDX, data_base)
# ECX is a counter starting from 0.
uc.reg_write(UC_X86_REG_ECX, 0)
# Write new stack position.
uc.reg_write(UC_X86_REG_ESP, ESP)

# ----- Arguments Setup End ----- #

# ---- Handling ECX access violation ---- #
# mov [ecx], eax.

decrypted_base = 0x00000000
decrypted_size = 0x00100000

uc.mem_map(decrypted_base, decrypted_size, UC_PROT_ALL)
uc.mem_write(decrypted_base, b"\x00" * decrypted_size)

# -- Handling ECX access violation end -- #


code_base = 0x00400000
code_size = 0x00100000

# Map target memory with r/w/x permissions
uc.mem_map(code_base, code_size, UC_PROT_ALL)
uc.mem_write(code_base, b"\x00" * code_size)

# Write our code into the target memory
uc.mem_write(code_base, code)
code_end = code_base + len(code)
uc.emu_start(code_base, code_end, timeout=0, count=0)

print(bytes(uc.mem_read(UC_X86_REG_ECX, 0x1000)).decode('utf-8', errors='ignore').replace('`',''))
#print(bytes(output).decode('utf-8', errors='ignore').replace('`', ''))
