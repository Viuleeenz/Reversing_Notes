from capstone import *
from unicorn import *
from unicorn.x86_const import *
import pefile
import codecs
import re
import sys


def emulate_decryption_routine(code):
      # Unicorn emulator setup
    uc = Uc(UC_ARCH_X86, UC_MODE_32)
    
    stack_base = 0x00100000
    stack_size = 0x001000
    
    # Position the stack pointer in the middle of the stack
    ESP = stack_base + (stack_size // 2)
    EBP = stack_base + (stack_size // 2)
    
    
    # Map the stack memory into the emulator
    uc.mem_map(stack_base, stack_size)
    
    # Fill the stack memory with null bytes
    uc.mem_write(stack_base, b"\x00" * stack_size)
    
    # Set the stack pointer
    uc.reg_write(UC_X86_REG_EBP, EBP)
    uc.reg_write(UC_X86_REG_ESP, ESP)
    
    data_base = 0x00000000
    data_size = 0x00100000
    
    # Map the data memory with r/w/x permissions
    uc.mem_map(data_base, data_size, UC_PROT_ALL)
    
    # Fill the target memory with null bytes
    uc.mem_write(data_base, b"\x00" * data_size)
    
    # Set function argument
    uc.reg_write(UC_X86_REG_ECX, data_base)
    
    target_base = 0x00400000
    target_size = 0x00100000
    
    # Map target memory with r/w/x permissions
    uc.mem_map(target_base, target_size, UC_PROT_ALL)
    
    # Fill the target memory with null bytes
    uc.mem_write(target_base, b"\x00" * target_size)
    
    # Write our code into the target memory
    uc.mem_write(target_base, code)
    
    target_end = target_base + len(code)

    # Add our tracking hook to run on every instruction
    #uc.hook_add(UC_HOOK_CODE, trace, None)
    uc.emu_start(target_base, target_end, timeout=0, count=0)

    EBP = uc.reg_read(UC_X86_REG_EBP)
    return uc.mem_read(stack_base, stack_size)

def format_output(decrypted_string):
    out_string = decrypted_string.hex().replace('00','')
    byte_values = bytes.fromhex(out_string)
    print(f'{hex(image_base + m.end() + code_section_rva - 1024)} {byte_values}')
                    

cs = Cs(CS_ARCH_X86, CS_MODE_32)
cs.detail = True

if not len(sys.argv) >  1:
    print('[-] Missing file...')
    exit()

filename = sys.argv[1]
pe = pefile.PE(filename)
file_data = open(filename,'rb').read()
image_base = 0x400000
code_section_rva = None
for section in pe.sections:
    if section.Name.decode().strip('\x00') == '.text':
        code_section_rva = section.VirtualAddress
        section_offset = section.PointerToRawData
        data = section.get_data()
        break

if code_section_rva is None:
    print("Code section (.text) not found.")
    exit()

#look for last instruction related to the decryption routine
egg = rb'\x83(\xF8|\xF9).\x73.(\x8A|\x8D)..\xEB.'
start_address = None

for m in re.finditer(egg, file_data):
    data_block = file_data[m.start()-500:m.end()]
    string = file_data[m.end()-5:m.end()-2] 
    disasm = list(cs.disasm(string, 0, len(string)))
    offset = (disasm[0].operands[1].value.mem.disp)
    disasm_list = list(cs.disasm(data_block, 0, len(data_block)))
    
    offset_found = False
    
    for i in reversed(disasm_list):
        if i.mnemonic == 'mov' and i.operands[0].type == 3:
            if i.operands[0].value.mem.disp == offset:
                offset_found = True
                start_address = i.address
                
        elif i.mnemonic in ['lea','mov','sub','inc','or','dec','jns','and','movsx']:
                #print(i.op_str.split(',')[0])
                start_address = i.address
        else:
            if offset_found:
                try:
                    block_to_emulate = data_block[start_address:m.end()]
                    decrypted_string = emulate_decryption_routine(block_to_emulate)
                    format_output(decrypted_string)
                    
                    
                except:
                    print(f'[!ERROR]{hex(image_base + m.end() + code_section_rva - 1024)}')
                    print(f'Run Code manually: {block_to_emulate.hex()}')
                break
        
