def MurMurHash2(func_name):
    code = bytes.fromhex('56 57 8B F9 8B D7 8D 4A 01 8A 02 42 84 C0 75 F9 2B D1 8B F2 83 F6 20 83 FA 04 7C 4D 53 8B DA C1 EB 02 6B C3 FC 03 D0 0F B6 4F 03 0F B6 47 02 C1 E1 08 0B C8 69 F6 95 E9 D1 5B 0F B6 47 01 C1 E1 08 0B C8 0F B6 07 C1 E1 08 83 C7 04 0B C8 69 C9 95 E9 D1 5B 8B C1 C1 E8 18 33 C1 69 C8 95 E9 D1 5B 33 F1 83 EB 01 75 BF 5B 83 EA 01 74 1C 83 EA 01 74 0E 83 EA 01 75 1D 0F B6 47 02 C1 E0 10 33 F0 0F B6 47 01 C1 E0 08 33 F0 0F B6 07 33 C6 69 F0 95 E9 D1 5B 8B C6 C1 E8 0D 33 C6 69 C8 95 E9 D1 5B 5F 5E 8B C1 C1 E8 0F 33 C1')
    
    # Unicorn emulator setup
    uc = Uc(UC_ARCH_X86, UC_MODE_32)
    
    stack_base = 0x00100000
    stack_size = 0x00100000
    
    # Position the stack pointer in the middle of the stack
    ESP = stack_base + (stack_size // 2)
    
    # Map the stack memory into the emulator
    uc.mem_map(stack_base, stack_size)
    
    # Fill the stack memory with null bytes
    uc.mem_write(stack_base, b"\x00" * stack_size)
    
    # Set the stack pointer
    uc.reg_write(UC_X86_REG_ESP, ESP)
    
    data_base = 0x00600000
    data_size = 0x00100000
    
    # Map the data memory with r/w/x permissions
    uc.mem_map(data_base, data_size, UC_PROT_ALL)
    
    # Fill the target memory with null bytes
    uc.mem_write(data_base, b"\x00" * data_size)
    uc.mem_write(data_base, func_name)
    
    # Set function argument
    uc.reg_write(UC_X86_REG_ECX, data_base)
    
    target_base = 0x00400000
    target_size = 0x00100000
    
    # Map target memory with r/w/x permissions
    uc.mem_map(target_base, target_size, UC_PROT_ALL)
    
    # Fill the target memory with null bytes
    uc.mem_write(target_base, b"\x00" * target_size)
    
    # Write our code into the target memory
    uc.mem_write(target_base, code)
    
    target_end = target_base + len(code)
    
    uc.emu_start(target_base, target_end, timeout=0, count=0)
    
    EAX = uc.reg_read(UC_X86_REG_EAX)
    return EAX
