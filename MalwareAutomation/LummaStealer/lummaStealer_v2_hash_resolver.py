import re
import os
import os.path
import pefile
from unicorn import *
from unicorn.x86_const import *
from capstone import *
from capstone.x86 import *

def MurMurHash2(func_name):
    code = bytes.fromhex('56 57 8B F9 8B D7 8D 4A 01 8A 02 42 84 C0 75 F9 2B D1 8B F2 83 F6 20 83 FA 04 7C 4D 53 8B DA C1 EB 02 6B C3 FC 03 D0 0F B6 4F 03 0F B6 47 02 C1 E1 08 0B C8 69 F6 95 E9 D1 5B 0F B6 47 01 C1 E1 08 0B C8 0F B6 07 C1 E1 08 83 C7 04 0B C8 69 C9 95 E9 D1 5B 8B C1 C1 E8 18 33 C1 69 C8 95 E9 D1 5B 33 F1 83 EB 01 75 BF 5B 83 EA 01 74 1C 83 EA 01 74 0E 83 EA 01 75 1D 0F B6 47 02 C1 E0 10 33 F0 0F B6 47 01 C1 E0 08 33 F0 0F B6 07 33 C6 69 F0 95 E9 D1 5B 8B C6 C1 E8 0D 33 C6 69 C8 95 E9 D1 5B 5F 5E 8B C1 C1 E8 0F 33 C1')
    
    # Unicorn emulator setup
    uc = Uc(UC_ARCH_X86, UC_MODE_32)
    
    stack_base = 0x00100000
    stack_size = 0x00100000
    
    # Position the stack pointer in the middle of the stack
    ESP = stack_base + (stack_size // 2)
    
    # Map the stack memory into the emulator
    uc.mem_map(stack_base, stack_size)
    
    # Fill the stack memory with null bytes
    uc.mem_write(stack_base, b"\x00" * stack_size)
    
    # Set the stack pointer
    uc.reg_write(UC_X86_REG_ESP, ESP)
    
    data_base = 0x00600000
    data_size = 0x00100000
    
    # Map the data memory with r/w/x permissions
    uc.mem_map(data_base, data_size, UC_PROT_ALL)
    
    # Fill the target memory with null bytes
    uc.mem_write(data_base, b"\x00" * data_size)
    uc.mem_write(data_base, func_name) # <- INSERT HERE YOUR FUNCTION NAME
    
    # Set function argument
    uc.reg_write(UC_X86_REG_ECX, data_base)
    
    target_base = 0x00400000
    target_size = 0x00100000
    
    # Map target memory with r/w/x permissions
    uc.mem_map(target_base, target_size, UC_PROT_ALL)
    
    # Fill the target memory with null bytes
    uc.mem_write(target_base, b"\x00" * target_size)
    
    # Write our code into the target memory
    uc.mem_write(target_base, code)
    
    target_end = target_base + len(code)
    
    uc.emu_start(target_base, target_end, timeout=0, count=0)
    
    EAX = uc.reg_read(UC_X86_REG_EAX)
    return EAX

filter = ['kernel32.dll', 'ntdll.dll','crypt32.dll','wininet.dll','advapi32.dll','user32.dll']
    
def get_all_export_function_from_dlls():
    exported_func = {}
    for dirpath, dirnames, filenames in os.walk("C:\\Windows\\System32"):
        for filename in [f for f in filenames if f in filter]:
            path_to_dll = os.path.join(dirpath, filename)
            pe = pefile.PE(path_to_dll)
            for export in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                if not export.name:
                    continue
                else: 
                    exported_func[hex(MurMurHash2(export.name))] = export.name
    return exported_func
                
def filter_bytes(data, function_map):
    # disassemble .text section
    cs = Cs(CS_ARCH_X86, CS_MODE_32)
    cs.detail = True
    cs.skipdata = True
    replace_start = 0
    for insn in cs.disasm(data, 0):
        try:
            if len(insn.operands) > 1 and insn.operands[0].type == X86_OP_REG and insn.operands[1].type == X86_OP_IMM:
                    #print(f' {hex(insn.operands[1].value.imm)} -> {function_map[hex(insn.operands[1].value.imm)]}')
                    return [hex(insn.operands[1].value.imm) , function_map[hex(insn.operands[1].value.imm)]]
        except:
            pass
            

extracted_funct = get_all_export_function_from_dlls()

file_data = open('277d7f450268aeb4e7fe942f70a9df63aa429d703e9400370f0621a438e918bf', 'rb').read()

pe = pefile.PE('277d7f450268aeb4e7fe942f70a9df63aa429d703e9400370f0621a438e918bf')
image_base = 0x400000
section_rva = 0
for s in pe.sections:
    if b'.text' in s.Name:
        section_rva = s.VirtualAddress
        section_offset = s.PointerToRawData
        data = s.get_data()

egg = rb'(\xB9|\xBF|\xBD|\xBA)....'
data = {}
s = 0
for m in re.finditer(egg, file_data):
    s = m.start()
    ida_address = hex(image_base + m.start() + section_rva - 1024)
    data[ida_address] = filter_bytes(file_data[m.start():m.end()], extracted_funct)

for r in data:
    if data[r] != None:
        print(data[r])
