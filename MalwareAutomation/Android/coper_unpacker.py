import struct
import os
import sys
import shutil
import subprocess
import re
from io import BytesIO
from elftools.elf.elffile import ELFFile
from Crypto.Cipher import ARC4

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def rc4_decrypt(key, data):
    cipher = ARC4.new(key)
    decrypted_data = cipher.decrypt(data)
    return decrypted_data

def unpack_apk_with_apktool(apk_path, output_dir):
    """
    Unpack APK using apktool command
    """
    try:
        result = subprocess.run(
            ['apktool', 'd', '-o', output_dir, apk_path],
            capture_output=True,
            text=True,
            timeout=60
        )
        
        if result.returncode != 0:
            print(f"[-] apktool error: {result.stderr}")
            return False
        
        print(f"[+] APK unpacked to: {output_dir}\n")
        return True
    except FileNotFoundError:
        print("[-] ERROR: apktool not found. Install with: apt-get install apktool")
        return False
    except Exception as e:
        print(f"[-] Error unpacking APK: {e}")
        return False

def extract_x86_lib_from_unpacked(unpacked_dir):
    """
    Extract x86 library from unpacked APK directory
    """
    lib_x86_path = os.path.join(unpacked_dir, 'lib', 'x86')
    
    if not os.path.exists(lib_x86_path):
        print(f"[-] No lib/x86 directory found in unpacked APK")
        return None, None
    
    # Find .so files
    so_files = [f for f in os.listdir(lib_x86_path) if f.endswith('.so')]
    
    if not so_files:
        print(f"[-] No .so files found in lib/x86")
        return None, None
    
    # Use first .so file
    lib_name = so_files[0]
    lib_path = os.path.join(lib_x86_path, lib_name)
    
    with open(lib_path, 'rb') as f:
        lib_data = f.read()
    
    return lib_name, lib_data

def find_ebx_initialization(lib_data):
    """
    Find the ebx initialization pattern and calculate ebx value
    """
    pos = 0
    while pos < len(lib_data) - 12:
        if lib_data[pos] == 0xe8:
            if pos + 5 < len(lib_data) and lib_data[pos + 5] == 0x5b:
                if pos + 6 < len(lib_data) and lib_data[pos + 6:pos + 8] == b'\x81\xc3':
                    add_displacement = struct.unpack('<i', lib_data[pos + 8:pos + 12])[0]
                    pop_offset = pos + 5
                    ebx_offset = pop_offset + add_displacement
                    return ebx_offset
        pos += 1
    
    return None

def extract_strings_from_lib(lib_data, ebx_value):
    """
    Extract paired xmmword strings from the library
    """
    try:
        f = BytesIO(lib_data)
        elf = ELFFile(f)
        
        text_section = elf.get_section_by_name('.text')
        if not text_section:
            return None
        
        text_vaddr = text_section['sh_addr']
        text_data = text_section.data()
        
        pattern = b'\x0F\x28\x83'
        matches = []
        pos = 0
        
        while pos < len(text_data):
            idx = text_data.find(pattern, pos)
            if idx == -1:
                break
            if idx + 7 <= len(text_data):
                displacement_bytes = text_data[idx + 3:idx + 7]
                displacement = struct.unpack('<i', displacement_bytes)[0]
                data_vaddr = ebx_value + displacement
                
                target_section = None
                target_section_offset = None
                
                for section in elf.iter_sections():
                    section_vaddr = section['sh_addr']
                    section_size = section['sh_size']
                    if section_vaddr <= data_vaddr < section_vaddr + section_size:
                        target_section = section
                        target_section_offset = data_vaddr - section_vaddr
                        break
                
                if target_section:
                    section_data = target_section.data()
                    if target_section_offset + 16 <= len(section_data):
                        xmmword = section_data[target_section_offset:target_section_offset + 16]
                        matches.append(xmmword)
            
            pos = idx + 1 
        candidate_keys = []
        resource_string = None
        not_allowed_chars = set('()/;,.')
        for i in range(0, len(matches) - 1, 2):
            hex_combined = matches[i].hex() + matches[i + 1].hex()
            try:
                ascii_string = bytes.fromhex(hex_combined).decode('ascii', errors='replace') 
                nascii_string = ascii_string.replace('\x00','')
                res = get_resource_name(nascii_string)
                if res is not None:
                    resource_string = nascii_string
                elif len(nascii_string) != 32 or any((c in not_allowed_chars) for c in nascii_string):
                    pass
                else:
                    candidate_keys.append(nascii_string)


            except:
                pass

        return candidate_keys, resource_string
    
    except Exception as e:
        print(f"[-] Error parsing ELF: {e}")
        return None

def find_encrypted_res(unpacked_dir, resource_path):
    """
    Find resource file in unpacked APK directory
    resource_path format: "raw/filename"
    """
    # First, try direct path
    direct_path = os.path.join(unpacked_dir, 'res', resource_path)
    if os.path.exists(direct_path):
        return direct_path
    
    # Extract filename from resource_path
    if '/' in resource_path:
        _, filename = resource_path.rsplit('/', 1)
    else:
        filename = resource_path
    
    # Search in res/ directory tree
    res_dir = os.path.join(unpacked_dir, 'res')
    if os.path.exists(res_dir):
        for root, dirs, files in os.walk(res_dir):
            for file in files:
                if file == filename:
                    full_path = os.path.join(root, file)
                    print(f"[+] Found resource at: {full_path}")
                    return full_path
    
    # Search in assets
    assets_dir = os.path.join(unpacked_dir, 'assets')
    if os.path.exists(assets_dir):
        for root, dirs, files in os.walk(assets_dir):
            for file in files:
                if file == filename:
                    full_path = os.path.join(root, file)
                    print(f"[+] Found resource at: {full_path}")
                    return full_path
    
    return None

def get_resource_name(s):
    match = re.search(r'raw/(.+)', s)
    if match:
        resource_name = match.group(1)
        return resource_name
    return None

def get_data_type(data):
    if data.startswith(b'PK\x03\x04'):
        return "ZIP archive (DEX/APK)"
    elif data.startswith(b'\x64\x65\x78\x0a'):
        return "DEX file"
    else:
        return None


def bruteforce_raw_resources(unpacked_dir, candidate_keys):
    """
    Bruteforce RC4 decryption on raw resources using all candidate keys
    Returns: (decrypted_data, resource_file_path, rc4_key) or (None, None, None) if not found
    """
    raw_dir = os.path.join(unpacked_dir, 'res', 'raw')
    
    if not os.path.exists(raw_dir):
        print(f"[-] No res/raw directory found in unpacked APK")
        return None, None, None
    
    # Find all files in raw directory and subdirectories
    resource_files = []
    for root, dirs, files in os.walk(raw_dir):
        for file in files:
            full_path = os.path.join(root, file)
            resource_files.append(full_path)
    
    if not resource_files:
        print(f"[-] No resource files found in res/raw")
        return None, None, None
    
    print(f"[*] Found {len(resource_files)} resource file(s) in raw directory")
    print(f"[*] Attempting bruteforce decryption with {len(candidate_keys)} key(s)...\n")
    
    for resource_file_path in resource_files:
        relative_path = os.path.relpath(resource_file_path, unpacked_dir)
        print(f"[*] Testing: {relative_path}")
        
        try:
            with open(resource_file_path, 'rb') as f:
                encrypted_data = f.read()
        except Exception as e:
            print(f"    [-] Error reading file: {e}")
            continue
        
        for key_index, rc4_key in enumerate(candidate_keys):
            try:
                decrypted_data = rc4_decrypt(rc4_key.encode(encoding="utf-8"), encrypted_data)
                data_type = get_data_type(decrypted_data)
                if data_type is not None:
                    print(f"    [+] Found valid {data_type} with key #{key_index}")
                    print(f"    [+] RC4 Key: {bcolors.OKGREEN} {rc4_key} {bcolors.ENDC}")
                    print(f"    [+] Decrypted successfully: {len(decrypted_data)} bytes\n")
                    return decrypted_data, resource_file_path, rc4_key
                    
            except Exception as e:
                continue
        
        print(f"    [-] No valid decryption found for this file")
    
    return None, None, None

def save(decrypted_data):
    output_file = "decrypted_payload.dex"
    with open(output_file, 'wb') as f:
        f.write(decrypted_data)
    print(f"[+] Saved decrypted payload to: {bcolors.HEADER}{output_file}{bcolors.ENDC}\n")
            

def analyze_apk(apk_path):
    print(f"[*] Analyzing APK: {apk_path}\n")
    # Create temp directory in current location
    script_dir = os.path.dirname(os.path.abspath(__file__))
    temp_dir = os.path.join(script_dir, 'apk_temp')
    
    try:
        print("[*] Unpacking APK with apktool...")
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)
        
        if not unpack_apk_with_apktool(apk_path, temp_dir):
            return False
        
        print("[*] Extracting x86 native library...")
        lib_name, lib_data = extract_x86_lib_from_unpacked(temp_dir)
        
        if lib_name is None:
            print("[-] ERROR: Could not find x86 native library")
            return False
        
        print(f"[+] Found: {lib_name} ({len(lib_data)} bytes)\n")
        
        print("[*] Finding ebx initialization...")
        ebx_value = find_ebx_initialization(lib_data)
        
        if ebx_value is None:
            print("[-] ERROR: Could not find ebx initialization pattern")
            return False
        
        print(f"[+] ebx base: 0x{ebx_value:x}\n")
        
        print("[*] Extracting and decoding strings...")
        candidate_keys, resource_string = extract_strings_from_lib(lib_data, ebx_value)
        
        if candidate_keys is None or len(candidate_keys) < 1:
            print("[-] ERROR: Could not extract candidate keys")
            return False

        elif resource_string is not None:
            rc4_key = candidate_keys
            resource_identifier = resource_string

        # Case 1: Resource identifier found in strings
            print("[+] Extracted Information:")
            print(f"    RC4 Key(s): {candidate_keys}")
            print(f"    Resource ID: {resource_identifier}\n")
            
            # Parse resource identifier (format: "namespace:resource_path")
            namespace, resource_path = resource_identifier.split(':', 1)
            resource_path = resource_path.rstrip('\x00')
            
            print(f"    Namespace: {namespace}")
            print(f"    Resource Path: {bcolors.OKGREEN} {resource_path} {bcolors.ENDC}\n")
            
            print("[*] Finding encrypted resource in unpacked APK...")
            resource_file_path = find_encrypted_res(temp_dir, resource_path)
            
            if resource_file_path is None:
                print(f"[-] ERROR: Could not find resource '{resource_path}'")
                print(f"[-] Searched in: res/, assets/")
                print(f"[-] Please check apktool folder and make sure about file location.")
                return False
            
            with open(resource_file_path, 'rb') as f:
                encrypted_data = f.read()
            
            print(f"[+] Extracted encrypted resource: {len(encrypted_data)} bytes\n")
            print("[*] Decrypting resource with RC4...")

            for rc4_key in candidate_keys:
                try:
                    decrypted_data = rc4_decrypt(rc4_key.encode(encoding="utf-8"), encrypted_data)
                    data_type = get_data_type(decrypted_data)
                    if data_type:
                        print(f"    [+] Decrypted successfully: {len(decrypted_data)} bytes\n")
                        print(f"    [+] RC4 Key: {bcolors.OKGREEN} {rc4_key} {bcolors.ENDC}")
                        print(f"    [+] Data type: {data_type}\n")

                        save(decrypted_data)
                        
                        return True
                    else:
                        print("[-] ERROR: Could not find valid decrypted resource/key pair")
                        return False
                    
                
                except Exception as e:
                    print(f"[-] ERROR during decryption: {e}")
                    return False
        
        # Case 2: Resource identifier not found, bruteforce raw resources
        else:
            print("[-] Resource identifier not found in extracted strings")
            print("[*] Initiating bruteforce attack on raw resources...\n")
            
            decrypted_data, resource_file_path, found_key = bruteforce_raw_resources(temp_dir, candidate_keys)
            
            if decrypted_data is None:
                print("[-] ERROR: Could not find valid decrypted resource via bruteforce")
                print(f"[-] Collected candidate keys: {candidate_keys}")
                return False
             
            save(decrypted_data)

            return True
    
    finally:
        if os.path.exists(temp_dir):
            print("[*] Cleaning up temporary files...")
            shutil.rmtree(temp_dir, ignore_errors=True)
            print("[+] Cleanup complete\n")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        help_text = """
        Coper Loader Unpacker - Extract and decrypt Coper payloads for x86 architecture

        USAGE:
          python coper_loader_unpacker.py <apk_file> 

        ARGUMENTS:
          <apk_file>              Path to the APK file to analyze

        REQUIREMENTS:
          • apktool              apt-get install apktool
          • pyelftools           pip install pyelftools

        WORKFLOW:
          1. Unpack APK with apktool
          2. Extract x86 native library (libc.so variants)
          3. Parse ELF binary for RC4 key and resource identifier
          4. Locate encrypted resource in res/raw/
          5. Decrypt using RC4
          6. Validate decrypted payload (DEX/APK signature)
          7. Save decrypted output and cleanup

        NOTES:
          - If resource ID not found, automatically bruteforces all res/raw/* files
          - Decrypted payload saved to: <cwd>/decrypted_payload.dex

        """
        print(help_text.strip())
        sys.exit(1)
        
    apk_file = sys.argv[1]
    
    if not os.path.exists(apk_file):
        print(f"[-] Error: File not found: {apk_file}")
        sys.exit(1)
    
    success = analyze_apk(apk_file)
    sys.exit(0 if success else 1)
